package com.github.halfmatthalfcat.prisma.scala

import scala.meta._
import com.github.halfmatthalfcat.prisma.dmmf.{Field, FieldDefaultKind, IsFieldDefault}

object FieldConversion {

  def getField(field: Field): Term.Param = {
    val name = Term.Name(field.name)
    val `type` = getFieldType(field)
    val default = getFieldDefault(field)

    default.map { d =>
      param"$name: ${`type`} = $d"
    }.getOrElse(param"$name: ${`type`}")
  }

  private[scala] def getFieldType(field: Field): Type = {
    var `type` = TypeConversion.typeKindToType(field.`type`)

    if (field.isList) {
      `type` = t"Seq[${`type`}]"
    }

    /**
     * Should be option if its any value generated by the underlying
     * database. This includes static values, dates or dbgenerated.
     * Things prisma-client-scala generates mustn't be Option(al) as
     * we're going to be setting the default value on the model field.
     * */
    val shouldBeOption = field.default.map {
      case IsFieldDefault(fd) if !Seq(
        FieldDefaultKind.UUID,
        FieldDefaultKind.CUID,
      ).contains(fd.kind) => true
      case _ => false
    }.getOrElse(!field.isRequired)

    if (shouldBeOption) {
      `type` = t"Option[${`type`}]"
    }

    `type`
  }

  private[scala] def getFieldDefault(field: Field): Option[Term.Apply] = field.default match {
    case Some(IsFieldDefault(fd)) if fd.kind == FieldDefaultKind.UUID =>
      Some(q"java.util.UUID.randomUUID()")
    case Some(IsFieldDefault(fd)) if fd.kind == FieldDefaultKind.CUID =>
      Some(q"com.github.f4b6a3.ulid.UlidCreator.getUlid()")
    case _ => Option.empty
  }

}
